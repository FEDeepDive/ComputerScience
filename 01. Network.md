## 1. 네트워크의 기초

### 처리량(Throughput), 지연 시간(Latency)

|  | 처리량(Throughput) | 대역폭(Bandwidth) |
| --- | --- | --- |
| 정의 | 네트워크 제한에 따라 특정 순간에 전송할 수 있는 실제 데이터의 양 | 단위 시간 내에 전달할 수 있는 데이터의 최대 용량 |
| 설명 | 네트워크에서 성공적으로 전송된 데이터의 양, 네트워크의 실제 성능 | 이론적으로 특정 네트워크에서 한 번에 이동 가능한 데이터의 양 |
| 관계 비유 | 관을 따라 흐르는 물 | 물이 흐르는 관 |

|  | 응답 시간(Response time) | 지연 시간(Latency) |
| --- | --- | --- |
| 정의 | 사용자가 요청을 보낸 후 첫 번째 응답을 받기까지 걸리는 시간 | 데이터가 네트워크를 통해 두 지점 사이를 왕복하는 데 걸리는 시간 |
| 설명 | 사용자의 요청을 실제로 처리하는 시간과 지연 시간을 합한 것 | 거리, 인터넷 인프라 및 기타 변수로 인해 발생하는 시간을 합한 것 |
| 관계 | 처리 시간 + 지연 시간 | 응답 시간 - 처리 시간 |

**지연 시간과 관련된 기술 키워드**

- TTFB(Time-To-First-Byte)
- 콘텐츠 전송 네트워크(Content Delivery/Distribution Network)
- 엣지 컴퓨팅(Edge computing)

### 네트워크 토폴로지와 병목 현상

네트워크 토폴로지는 컴퓨터 네트워크의 요소들, 즉 노드(개별 기기)와 링크(통신 회선)가 연결된 구조를 의미하는 ‘물리적 토폴로지’와 노드들 사이에서 이루어지는 실질적 데이터 흐름에 따라 결정되는 ‘논리적 토폴로지’로 나뉜다.

| 이름 | 설명 |
| --- | --- |
| 버스 토폴로지 | 중앙 링크 하나에 여러 개의 노드가 연결되어 공유하는 구성. 모든 노드가 하나의 링크를 공유하므로, 해당 링크에서 주로 병목이 발생한다. |
| 스타 토폴로지 | 모든 노드를 중앙의 단일 노드에 연결하여 얻을 수 있는 구성. 모든 데이터 흐름이 중앙 단일 노드를 거쳐야 하므로, 해당 노드에서 주로 병목이 발생한다. |
| 링 토폴로지 | 각 노드를 양 옆의 두 노드와 연결하여 고리 형태의 연속된 링크를 통해 통신하는 구성. 데이터의 흐름이 단방향이기 때문에 노드의 개수가 늘어날수록 성능 저하가 일어나며 어느 한 곳이라도 장애가 발생하면 전체 네트워크에 영향이 간다. |
| 트리 토폴로지 | 스타 토폴로지를 계층 구조로 연결하여 얻을 수 있는 구성. 계층 구조를 가지기 때문에 상위 노드에서 병목이 발생할 경우 하위 노드 전체가 영향을 받는다. |
| 메시 토폴로지 | 모든 노드가 서로에게 직접 연결된 구성. 네트워크 내 가장 성능이 떨어지는 링크에서 병목이 주로 발생하며, 때문에 메시 네트워크의 성능은 노드 간 개별 링크의 대역폭에 좌우된다. |

### 네트워크 분류

네트워크는 데이터를 주고받는 범위에 따라 분류할 수 있으며, 일반적으로 LAN, MAN, WAN의 세 가지로 나누곤 한다. 

| 분류 | 설명 |
| --- | --- |
| LAN(Local Area Network, 근거리 통신망) | 일반적으로 건물 하나 정도의 작은 지역을 한데 묶은 네트워크. ex) 가정용 Wi-Fi 네트워크, 사무실 네트워크 등 |
| MAN(Metropolitan Area Network, 도시권 통신망) | 도시의 한 구역 또는 하나의 도시를 한데 묶은 네트워크. 상호 연결된 LAN으로 구성됨. LAN보다는 크지만 WAN보다는 작으며, 일반적으로 WAN보다 효율적. 캠퍼스 영역 네트워크(CAN)은 MAN의 일종으로 간주할 수 있음. |
| WAN(Wide Area Network, 광역 통신망) | 한 국가나 대륙 또는 전 세계에 걸친 광범위한 지역을 한데 묶은 네트워크. 상호 연결된 LAN으로 구성되어, 네트워크의 네트워크라고 이해할 수 있음. ex) 인터넷 |

### 네트워크 프로토콜 표준화

네트워크 프로토콜이란 같은 네트워크 내 둘 이상의 장치 간에 정보를 주고받기 위해 사용하는 규약을 의미한다. 서로 다른 기종 간에도 통신을 가능하게 하기 위해 여러 단체에 의해 수많은 프로토콜이 표준화되고 있다.

| 프로토콜 | 표준화 단체 |
| --- | --- |
| https://standards.ieee.org/ieee/802.3/10422/ | https://www.ieee802.org/3/ |
| https://standards.ieee.org/ieee/802.11/7028/ | https://www.ieee802.org/11/ |
| https://www.ietf.org/rfc/rfc793.txt | https://www.ietf.org/ |
| https://httpwg.org/specs/ | https://httpwg.org/ |

## 2. OSI 모델 vs. TCP/IP 모델

OSI 모델은 네트워크를 통해 애플리케이션이 통신할 수 있는 방법을 정의하는 개념적 모델로, 데이터 전송 과정을 단계적으로 자세히 보여준다. 그러나 TCP/IP 모델은 TCP/IP 프로토콜 통신 과정에 초점을 맞추어 OSI 모델을 단순화한 실무적 모델이다.

### 프로토콜 데이터 단위(PDU)

네트워크를 통해 전송되는 데이터는 각 계층을 거치며 헤더 정보가 추가되며 이름이 달라진다. 이 과정을 캡슐화(encapsulation)이라고 하며 헤더에 붙는 추가 정보를 **프로토콜 제어 정보(Protocol Control Information, PDI)**, 실제로 전송되는 정보를 **서비스 데이터 단위(Sertive Data Unit, SDU)**라고 한다. 즉, PDU = SDU + PDI이다.

| TCP/IP 모델 | OSI 모델 | 프로토콜 데이터 단위 |
| --- | --- | --- |
| 응용 계층 | 응용 계층 + 표현 계층 + 세션 계층 | 메시지 |
| 전송 계층 | 전송 계층 | 세그먼트(TCP) / 데이터그램(UDP) |
| 인터넷 계층 | 네트워크 계층 | 패킷 |
| 네트워크 인터페이스 계층 | 데이터 링크 계층 + 물리 계층 | 비트(물리), 프레임(데이터 링크) |

## 3. 네트워크 기기

각 네트워크 기기는 처리할 수 있는 계층이 다르며, 상위 계층을 처리하는 기기는 하위 계층을 처리할 수 있지만 그 반대는 불가능하다.

| 기기 이름 | 처리 가능 계층 | 설명 |
| --- | --- | --- |
| L7 스위치(로드밸런서) | 응용 계층 및 하위 계층(TCP/IP 4계층) | 응용 계층의 여러 정보(URL, HTTP 헤더 등)를 분석하여 보안에 더 유리하고 정교하게 부하를 분산할 수 있음 |
| L4 스위치(로드밸런서) | 전송 계층 및 하위 계층(TCP/IP 3계층) | 전송 계층 관련 정보(포트 번호 등)를 활용하여 부하를 분산함 |
| 라우터, L3 스위치 | 인터넷 계층 및 하위 계층(TCP/IP 2계층) |  |
| 브릿지 또는 L2 스위치(데이터) | 데이터 링크 계층(OSI 2계층) |  |
| 리피터, 허브 | 물리 계층(OSI 1계층) |  |

### 스위치 vs. 라우터

일반적으로 스위치는 내부 네트워크 간 통신만이 가능하지만, 라우터는 내부와 외부 네트워크 신호를 구분할 수 있기 때문에 외부 네트워크 간 통신이 가능하다. 보통 데이터 링크 계층을 처리하는 ‘L2 스위치’를 줄여서 스위치라고 부르며, `L(N + 1)` 스위치는 `L(N)` 스위치의 동작에 다른 기능이 추가되었음을 의미한다.

### 브릿지 vs. 스위치

브릿지는 데이터 링크 계층의 PDU인 프레임을 소프트웨어 방식으로 처리하지만 스위치는 하드웨어 방식으로 처리하여 속도가 훨씬 빠르다. 지원하는 포트의 수 또한 스위치가 브릿지보다 많다.

### 리피터 vs. 허브

리피터는 일대일 통신만 할 수 있지만, 허브는 여러 대의 기기와 통신할 수 있다.

## 4. IP 주소

### IP(Internet Protocol)

패킷 교환 방식 네트워크에서 사용하도록 설계된 통신 프로토콜이다. 헤더에 기록된 고정 길이의 출발지 및 도착지 주소 간에 패킷(또는 데이터그램)이라는 단위의 데이터를 송수신할 수 있는 기능을 제공한다. IP는 크게 ‘주소 지정’과 ‘패킷 분할 및 병합’의 두 가지 기능을 구현한다. 출발지에서 도착지로 패킷을 보내는 기능만을 제공하도록 제한되어있기 때문에 별도로 신뢰성을 보장할 수 있는 방법이 없으며(비신뢰성), 패킷 교환 방식 네트워크에서 사용하도록 설계되었기 때문에 별도로 연결을 설정하고 유지하지 않는다(비연결성).

2024년 현재 IP 체계는 IPv4와 IPv6의 2가지 버전이 주로 사용되며, 두 버전의 가장 큰 차이는 주소를 나타내기 위해 사용하는 비트의 개수와 그 표현 방식이다.

|  | IPv4 | IPv6 |
| --- | --- | --- |
| 출발지/도착지 비트 수 | 32비트 | 128비트 |
| 표현 가능한 주소 개수 | 약 4.20 × 10^9 가지 | 약 3.40 × 10^38 가지 |
| 표현 방식 | 온점(.)으로 구분된 0~255 사이의 십진수 4개(ex. 192.168.0.1) | 콜론(:)으로 구분된 4자리의 16진수 8개(ex. 2001:0db8:85a3:0000:0000:8a2e:0370:7334) |

<aside>
💡 비트 수에 따라 표현 가능한 주소 개수가 늘어나는 모습은 CPU 레지스터나 메인보드의 주소 버스, 운영체제의 워드 크기가 커짐에 따라 한 번에 처리할 수 있는 데이터의 양이나 인식 가능한 RAM 용량이 늘어나는 것과 비슷한 형태임을 알 수 있다!

</aside>

### IPv4 주소 지정

인터넷 프로토콜 스위트(TCP/IP) 도입 초반에는 IP 주소를 5가지의 클래스로 나누어 배분하는 Classful 방식을 사용하였으나, 이는 충분히 유연하지 못한 방식이었다. 예를 들어, 디바이스가 300개인 조직은 254개의 호스트를 지원하는 클래스 C 주소를 사용할 수 없어 65,534개의 호스트를 지원하는 클래스 B 주소를 신청한 후 65,234개를 비워둬야 했다. 이는 주소 공간의 낭비를 야기하여 사용 가능한 IP 주소를 빠르게 소진하는 원인이 되었다.

이러한 단점을 해소하기 위해 1993년 이후부터는 CIDR(Classless Inter-Domain Routing) 방식을 사용하고 있다. 예를 들어 `192.168.0.1/24`와 같은 형식으로 표기하며, `/` 뒤의 수를 활용하여 네트워크 영역을 구분할 수 있다. CIDR 값이 24이므로 앞에서부터 24비트는 네트워크 ID, 남은 8비트를 호스트 ID로 해석하여 해당 네트워크 내의 호스트 ID가 `192.168.0.0` ~ `192.168.0.255`까지임을 알 수 있다.

### NAT(Network Address Translation)

IP 주소 고갈은 IPv4의 근본적인 문제로, 이를 완벽히 해결하는 방법은 IPv6를 사용하는 것뿐이다. 그러나 IPv4 주소의 특정 범위를 사설 네트워크에서만 사용할 수 있도록 한정시켜 인터넷의 공인 IP 주소를 절약하고, 외부 공격으로부터 사용자의 네트워크를 보호할 수 있게 해준다. 이때 사설 네트워크에 속한 여러 호스트가 하나의 공인 IP 주소를 통해 인터넷에 접속할 수 있도록, IP 패킷의 헤더를 수정하여 네트워크 트래픽을 주고받는 기법을 NAT라고 한다.

### DHCP(Dynamic Host Configuration Protocol)

클라이언트-서버 아키텍처를 이용하여 네트워크에 연결된 호스트의 IP 주소와 기타 설정들을 자동으로 할당해주는 프로토콜이다. DHCP 서버는 가용 IP 주소 및 기본 게이트웨이, 도메인명, 네임서버, 타임서버 등을 관리하며, 일반적으로 운영체제에 내장된 DHCP 클라이언트가 질의한 요청에 대해 응답하여 정보를 제공해준다. 이때, IP 주소는 영구적으로 할당되지 않으며 일정 기간 이후에도 사용하고자 한다면 연장, 사용을 종료하고 싶다면 반납 절차를 수행해야 한다.

## 5. HTTP

HTTP는 **신뢰성 있는(Reliable) ‘전송 계층’ 또는 ‘세션 계층’ 연결을 통해 동작(Connection-oriented)**하는 프로토콜이다. HTTP/2까지는 **TCP**, HTTP/3부터는 **QUIC**를 기반으로 동작한다.

### TCP(Transmission Control Protocol)

전송 계층(OSI 4계층)에 위치하는 프로토콜로, 네트워크에 연결된 두 호스트 내 프로세스 간에 신뢰성 있는 연결 지향적 서비스를 제공한다. 전송 계층은 네트워크 데이터를 특정 애플리케이션으로 보내도록 지정하는 방법을 제공하는 인터페이스 역할을 한다. 전송 계층과 애플리케이션 간의 통로 역할을 하는 내부 주소를 **‘포트(Port)’**라고 부른다.

1. 신뢰성 있다(Reliable): PDU의 순서가 바뀌거나, 손실 또는 중복이 없도록 보장함
2. 연결지향적이다(Connection-oriented): 데이터 통신이 이루어지기 전에 세션 또는 반영구적 연결이 설정됨

TCP에는 데이터 처리 속도를 조절하여 수신자의 처리 속도보다 빨리 데이터를 보내지 못하도록 제어하는 **‘흐름 제어(Flow control)’**와 네트워크 내 대기 패킷 수를 줄여 혼잡을 방지하거나 제어하는 **‘혼잡 제어(Congestion control)’** 기능이 있다.

### TCP 3-Way Handshake / 4-Way Handshake

HTTP 프로토콜로 통신을 시작하기 앞서, 통신하려는 두 주체인 양쪽 호스트(보통 브라우저와 서버)가 **‘TCP 3방향 핸드셰이크’** 과정을 통해 TCP 소켓 연결을 수립한다. 실제 요청 이전에 3개의 추가적인 세그먼트가 성공적으로 수신되어야 하기 때문에 이러한 이름이 붙었다.

1. **SYN**: 호스트(일반적으로 브라우저)가 **SYN**chronize 세그먼트를 서버로 보낸다.
2. **SYN-ACK**: 서버는 **SYN**을 수신하고 **SYN**chronize-**ACK**nowledgement 세그먼트를 다시 보낸다.
3. **ACK**: 호스트는 **SYN-ACK**을 수신하고 **ACK**nowledge 세그먼트를 다시 보낸다. 서버가 **ACK**를 수신하면 TCP 소켓 연결이 설정된다.

TCP 연결을 안전하게 종료하기 위해서, 통신을 진행하던 두 주체인 양쪽 호스트는 **‘TCP 4방향 핸드셰이크’** 과정을 진행해야 한다. 연결이 종료되기 전에 4개의 세그먼트가 성공적으로 수신되어야 하기 때문에 이러한 이름이 붙었다.

1. **FIN**: 연결을 먼저 요청한 호스트(이하 클라이언트)가 연결을 요청받은 호스트(이하 서버)에게 **FIN**ish 세그먼트를 보낸다.
2. **ACK**: 서버는 **FIN**을 수신하고 확인했다는 의미의 **ACK** 세그먼트를 클라이언트에게 보낸다. 아직 남은 데이터가 있다면 마저 전송을 마친다.
3. **FIN**: 데이터 전송이 끝났다면 이번엔 서버가 클라이언트에게 FIN 세그먼트를 보낸다.
4. **ACK**: 클라이언트는 **FIN**을 수신하고 확인했다는 의미의 ACK 세그먼트를 보낸 후, 아직 받지 못한 데이터가 있을 수 있으므로 기다린다. 서버는 **ACK**를 수신한 후 소켓을 닫으며, 클라이언트는 정해진 시간이 지난 후 소켓을 닫는다.

### TLS(Transport Layer Security)

개인 정보와 데이터 보완을 용이하게 하기 위해 설계된 암호화 프로토콜로, SSL(Secure Sockets Layer)에서 발전하였다. 제3자로부터 전송되는 데이터를 숨기는 **암호화**, 정보를 교환하는 당사자가 요청된 당사자임을 보장하는 **인증**, 데이터가 위변조되지 않았음을 확인하는 **무결성**을 달성한다. HTTP

### TLS Handshake

TLS 암호화를 사용하는 통신 세션을 수립하기 위해서는 TLS 핸드셰이크를 수행해야 한다. TLS 핸드셰이크는 TCP 3방향 핸드셰이크 과정이 진행되어 TCP 연결이 수립된 후 발생한다.

1. **ClientHello**: 클라이언트가 서버로 Hello 메시지를 전송한다.
    - 클라이언트가 지원하는 TLS 버전 및 암호화 방식, 대칭키를 만들기 위한 ‘클라이언트 무작위 값’ 등을 함께 보낸다.
2. **ServerHello**: 클라이언트의 Hello에 대한 응답으로 서버 클라이언트에게 또한 Hello 메시지를 전송한다.
    - 서버의 TLS 인증서 및 암호화 방식, ‘서버 무작위 값’ 등을 함께 보낸다.
3. **ClientKeyExchange**: 클라이언트가 인증서 발행 기관을 통해 인증서가 무결한지 검증했다면, 클라이언트와 서버의 무작위 값을 조합하여 ‘예비 마스터 암호(premaster secret)’를 만든 후 자신의 공개키로 암호화하여 서버로 전송한다. 이 값을 사용하여 세션에 사용될 대칭키를 생성한다.
4. **ChangeCipherSpec**: 이후 이루어지는 모든 통신은 핸드셰이크 과정에서 합의된 알고리즘과 대칭키를 이용하여 암호화된다.

### QUIC

기존 HTTPS 통신은 TCP와 TLS 세션 수립을 위해 두 번의 핸드셰이크 과정이 필요하며, 이 과정에서 불필요한 왕복이 일어나므로 RTT(Round Trip Time, 왕복 시간)를 줄이기 위해 비효율적인 단계를 줄일 필요가 있다. QUIC은 전송 프로토콜로 UDP를 채택하여 그 위에 구현한 프로토콜로, TCP에 존재하는 여러 신뢰성 및 흐름/혼잡 제어 등의 기능을 제공한다.