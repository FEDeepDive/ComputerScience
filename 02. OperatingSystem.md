## 1. 운영체제와 컴퓨터

### 컴퓨터 시스템의 하드웨어 구성 요소

| 이름 | 설명 |
| --- | --- |
| 중앙 처리 장치(Central Processing Unit, CPU) | 컴퓨터 시스템을 통제하고 연산을 처리하는 장치. 연산을 실제로 수행하는 ALU와 임시 저장 공간인 레지스터를 포함한다. |
| 주 기억 장치(Computer Memory) | 데이터와 명령을 일시적으로 기억하는 장치. 일반적으로 휘발성 메모리인 RAM을 가리킨다. |
| 보조 기억 장치(Computer Data Storage) | 데이터와 명령을 반영구적으로 보존하는 장치. 일반적으로 하드 디스크와 같이 비휘발성 메모리인 자기 기억 장치 등을 가리킨다. |
| 입출력 장치(Input/Output Device) | 컴퓨터 외부에 연결되어 컴퓨터 내부와 정보를 교환하는 장치. 흔히 모니터/키보드/마우스/프린터 등을 가리킨다. 보조 기억 장치와 입출력 장치를 합쳐 ‘주변 장치’라고도 부른다. |

현대적인 컴퓨터는 전자식 기억 장치에 명령어를 저장하는 ‘프로그램 내장 방식’을 채택하고 있다. 프로그램 내장 방식은 명령어 및 데이터를 저장하는 방식에 따라 ‘폰 노이반 구조’와 ‘하버드 구조’의 두 가지로 나뉜다. 최근에는 메모리부터 CPU까지는 폰 노이만 구조, CPU 내 캐시 시스템은 하버드 구조를 사용하는 방식을 취하고 있다.

| 폰 노이만 구조 | 명령어와 데이터가 같은 시스템 버스와 메모리를 사용한다. 구조가 단순해 구현이 쉽고 구현 비용이 낮지만 병목 현상이 발생할 수 있다. |
| --- | --- |
| 하버드 구조 | 명령어와 데이터 메모리를 분리하여 취급하기 때문에 각 메모리의 시스템 버스가 따로 존재한다. 폰 노이만 구조의 병목 현상을 해결하기 위해 등장했지만 구조가 복잡해 구현이 어렵고 구현 비용이 높다. |

### 운영체제

운영체제는 컴퓨터 시스템의 한정된 자원을 관리하고, 사용자가 컴퓨터를 편리하게 사용할 수 있도록 인터페이스를 제공하는 소프트웨어이다. 하드웨어 위에 설치되어, 하드웨어와 소프트웨어를 연결하는 계층으로써 한정된 자원 내에서 정확하고 빠르게 주어진 문제를 해결하기 위해 사용한다.

### 운영체제의 목적, 평가 기준

| 처리량(throughput) 향상 | 자원 관리를 통해 일정 시간 내에 시스템이 처리하는 일의 양을 향상시킨다. |
| --- | --- |
| 반환 시간(turnaround time) 단축 | 사용자가 시스템에 요청한 작업을 완료할 때까지 소요되는 시간을 단축시킨다. |
| 가용성(availability) 향상 | 요구 기능을 요구 시간 동안 올바르게 수행할 수 있는 능력을 향상시킨다. |
| 신뢰도(reliability) 향상 | 사용자의 입력 값에 대한 결과 값의 정확성을 향상시킨다. |

### 운영체제의 세 가지 개념

위에서 설명한 목적을 달성하기 위해, 운영체제는 세 가지의 요소를 다룬다.

| 가상화(Virtualization) | 물리적인 자원(CPU, 메모리, 디스크 등)을 편리하게 사용할 수 있도록 한다. |
| --- | --- |
| 병행성(Concurrency) | 여러 가지의 계산을 독립적으로 수행할 수 있도록 한다([#](https://roseline.oopy.io/dev/concurrency-and-parallelism)). |
| 영속성(Persistance) | 휘발성 기억장치에 기록된 정보를 지속적으로 저장할 수 있도록 한다. |

### 운영체제의 구성 요소

| 커널(Kernel) | 운영체제의 핵심 요소로 CPU 스케줄링, 메모리 관리, 입출력 관리, 파일 시스템 관리 등을 담당한다. 커널에서 실제로 다루는 역할의 양에 따라 크게 모놀리식커널과 마이크로커널로 나뉜다. |
| --- | --- |
| 셸(Shell) | 운영체제 서비스를 인간 사용자 또는 다른 프로그램에게 노출하고, 사용자와 운영체제 간 상호작용을 관리한다. 컴퓨터의 역할에 따라 CLI 또는 GUI 형태로 제공된다. |

### 시스템 콜(System Call)

운영체제는 CPU가 명령어를 실행하는 모드를 운영체제 서비스를 제공받을 수 있는 **커널 모드**와 그렇지 못하는 **사용자 모드**로 구분한다. 사용자 모드로 실행되는 프로그램이 하드웨어 자원에 접근하기 위해서는 운영체제에 요청을 보내 커널 모드로 전환되어야 하는데, 이때 보내는 요청을 시스템 콜이라고 한다.

## 2. 메모리

### 가상 메모리

컴퓨터 시스템의 가용 메모리 자원을 이상적으로 추상화하여 사용자에게 매우 큰 하나의 메모리로 보이게 하는 메모리 관리 기법 중 하나이다. 다른 말로, 특정 시간 동안 CPU를 사용할 수 있도록 할당받은 프로세스가 혼자 메모리를 사용하는 것처럼 **가상화**한 것을 의미한다.

CPU가 프로세스를 처리할 때 보는 주소와 실제 메모리의 주소는 서로 다르기 때문에 둘 간의 변환이 필요하며, 이러한 동작을 하는 하드웨어 장치를 **‘메모리 관리 장치(Memory Management Unit, MMU)’**라고 한다.

### 메모리 계층 구조

기억 장치를 **응답 시간**에 기반하여 계층 구조로 분류한 것으로 다음의 두 가지 사실에 기반한다.

- **참조 지역성(Locality of Reference)**: CPU는 짧은 시간 동안 기억 장치의 특정 부분에 집중적으로 접근하는 경향이 있다.
    - 시간 지역성(Temporal locality): 한 번 참조된 영역은 이후에도 자주 참조되는 경향이 있다.
    - 공간 지역성(Spatial locality): 한 번 참조된 영역의 근처 영역 또한 참조되는 경향이 있다.
- **CPU와 기억 장치 간의 거리와 가격, 용량, 속도 사이의 관계**: CPU에서 물리적, 논리적으로 멀리 떨어져 있을수록 속도가 느려지고 용량이 커지며 가격이 저렴해진다.

---

상대적으로 속도가 느리고 용량이 큰 기억 장치에서 참조 지역성을 활용하여 자주/곧 사용할 데이터를 선택한 후 상대적으로 속도가 빠르고 용량이 작은 기억 장치로 옮긴다.

| 계층 | 메모리 타입 | 가격(1~4) | 용량(1~4) | 속도(1~4) | 거리(1~4) |
| --- | --- | --- | --- | --- | --- |
| 0계층 | CPU 레지스터 | 4 | 1 | 4 | 1 |
| 1계층 | 캐시 메모리 | 3 | 2 | 3 | 2 |
| 2계층 | 주 기억 장치 | 2 | 3 | 2 | 3 |
| 3계층 | 보조 기억 장치 | 1 | 4 | 1 | 4 |

### 메모리 관리 전략

프로세스의 메모리 영역을 연속적으로 로드하느냐 나눠서 로드하느냐에 따라 연속 또는 비연속 메모리 할당이라고 부른다.

**연속 메모리 할당 방법**

| 고정 분할 방식 | 전체 메모리 영역을 일정한 크기로 분할한 뒤 각 영역에 프로세스를 할당하는 방식. 동시에 메모리에 올릴 수 있는 프로세스의 개수와 각 프로세스 크기가 제한되며, 단편화 문제가 발생할 수 있다. |
| --- | --- |
| 가변 분할 방식 | 할당할 프로세스의 크기에 따라 전체 메모리 영역을 분할하는 방식. 최초/최적/최악 적합 등의 메모리 할당 알고리즘을 이용해 가용 메모리 공간에서 프로세스가 로드될 수 있는 메모리 공간을 찾는다. |

**비연속 메모리 할당 방법**

| 페이징(Paging) | 프로세스의 논리 메모리 영역을 페이지, 물리 메모리 영역을 프레임으로 나눈 후, 각각 번호를 할당해 페이지와 프레임을 매핑한다. 두 단위의 크기는 동일하다. |
| --- | --- |
| 세그멘테이션(Segmentation) | 프로세스의 메모리 영역을 서로 크기가 다른 논리적 내용 단위인 세그먼트로 분할하여 메모리를 할당한다. 각 세그먼트의 크기가 다르기 때문에 시작 주소와 세그먼트 크기를 별도로 관리하는 자료 구조를 가지고 있어야 한다. |

참조 지역성에 의해 프로세스 전체가 메모리가 올라오지 않아도 프로세스를 실행하는 데에 문제가 없음을 알 수 있으며, 덕분에 현재 실행에 필요한 프로세스의 일부만 메모리에 로드하고 나머지는 디스크에 둔 상태로 프로세스를 실행하는 ‘**요구 페이징(demand paging)’**이 가능하다.

프로그램 실행 시에 물리 메모리에 필요한 페이지가 없을 경우 이를 페이지 폴트(page fault)라고 하며, 일정 수 이상으로 다중 프로그래밍을 하면 페이지 폴트가 자주 일어나 실질적으로 CPU 이용률이 떨어지는 **스레싱(thrashing)**이라는 현상이 발생한다.